// This code was GENERATED BY AI!!!!

// Curve functions
void curve1(float t, float* x, float* y) {
    float cos_t = cos(t);
    float sin_t = sin(t);
    float inner_t = (5.0f / 3.0f) * t;
    float cos_inner = cos(inner_t);
    float sin_inner = sin(inner_t);
    
    *x = 5.0f * cos_t + 3.0f * cos_inner;
    *y = 5.0f * sin_t - 3.0f * sin_inner;
}

void curve2(float t, float* x, float* y) {
    float cos_t = cos(t);
    float sin_t = sin(t);
    float inner_t = (11.0f / 5.0f) * t;
    float cos_inner = cos(inner_t);
    float sin_inner = sin(inner_t);
    
    *x = 11.0f * cos_t + 7.0f * cos_inner;
    *y = 11.0f * sin_t - 7.0f * sin_inner;
}

// Smooth step function for better anti-aliasing
__kernel void smooth_additive_curves(
    __global float* output,
    const int width,
    const int height,
    const float scale
) {
    int x = get_global_id(0);
    int y = get_global_id(1);
    
    if (x >= width || y >= height) return;
    
    float center_x = width * 0.5f;
    float center_y = height * 0.5f;
    int pixel_index = (y * width + x) * 3;
    
    output[pixel_index] = 0.0f;
    output[pixel_index + 1] = 0.0f;
    output[pixel_index + 2] = 0.0f;
    
    // Adaptive sampling based on scale - more samples for larger scales
    int samples = (int)(8000 * (scale / 20.0f)); // Scale-dependent sampling
    samples = clamp(samples, 8000, 20000); // Limit between 8k and 20k samples
    
    float min_distance1 = 1000.0f;
    float min_distance2 = 1000.0f;
    float best_t1 = 0.0f;
    float best_t2 = 0.0f;
    
    // Find closest points with high-quality sampling
    for (int i = 0; i < samples; i++) {
        float t1 = (float)i * (6.0f * M_PI_F / (float)samples);
        float t2 = (float)i * (10.0f * M_PI_F / (float)samples);
        
        // Curve 1
        float x1, y1;
        curve1(t1, &x1, &y1);
        float px1 = center_x + x1 * scale;
        float py1 = center_y + y1 * scale;
        float dx1 = (float)x - px1;
        float dy1 = (float)y - py1;
        float dist1 = sqrt(dx1 * dx1 + dy1 * dy1);
        
        if (dist1 < min_distance1) {
            min_distance1 = dist1;
            best_t1 = t1;
        }
        
        // Curve 2
        float x2, y2;
        curve2(t2, &x2, &y2);
        float px2 = center_x + x2 * scale;
        float py2 = center_y + y2 * scale;
        float dx2 = (float)x - px2;
        float dy2 = (float)y - py2;
        float dist2 = sqrt(dx2 * dx2 + dy2 * dy2);
        
        if (dist2 < min_distance2) {
            min_distance2 = dist2;
            best_t2 = t2;
        }
    }
    
    // Much smoother anti-aliasing with wider falloff
    float line_width1 = 2.5f; // Slightly thicker for curve 1
    float line_width2 = 3.0f; // Even thicker for curve 2
    
    float r1 = 0.0f, g1 = 0.0f, b1 = 0.0f;
    float r2 = 0.0f, g2 = 0.0f, b2 = 0.0f;
    
    // Curve 1 with smooth falloff
    if (min_distance1 <= line_width1 + 2.0f) {
        float alpha1 = 1.0f - smoothstep(line_width1 - 1.0f, line_width1 + 2.0f, min_distance1);
        
        // Dynamic colors based on position
        r1 = 0.1f + 0.3f * sin(best_t1 * 0.5f);
        g1 = 0.4f + 0.4f * cos(best_t1 * 0.7f + 1.0f);
        b1 = 0.7f + 0.2f * sin(best_t1 * 1.2f + 2.0f);
        
        r1 *= alpha1;
        g1 *= alpha1;
        b1 *= alpha1;
    }
    
    // Curve 2 with smooth falloff
    if (min_distance2 <= line_width2 + 2.0f) {
        float alpha2 = 1.0f - smoothstep(line_width2 - 1.0f, line_width2 + 2.0f, min_distance2);
        
        // Dynamic colors
        r2 = 0.7f + 0.2f * cos(best_t2 * 0.6f);
        g2 = 0.2f + 0.3f * sin(best_t2 * 0.8f + 1.5f);
        b2 = 0.5f + 0.3f * cos(best_t2 * 1.1f + 3.0f);
        
        r2 *= alpha2;
        g2 *= alpha2;
        b2 *= alpha2;
    }
    
    // Additive blending with saturation
    float r = min(1.0f, r1 + r2);
    float g = min(1.0f, g1 + g2);
    float b = min(1.0f, b1 + b2);
    
    // Apply gamma correction for better visual appearance
    r = pow(r, 0.8f);
    g = pow(g, 0.8f);
    b = pow(b, 0.8f);
    
    if (r > 0.0f || g > 0.0f || b > 0.0f) {
        output[pixel_index] = r * 255.0f;
        output[pixel_index + 1] = g * 255.0f;
        output[pixel_index + 2] = b * 255.0f;
    }
}
